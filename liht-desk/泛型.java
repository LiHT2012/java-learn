什么是泛型？为什么要使用泛型？

    泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

    泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

泛型只在编译阶段有效.在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。
泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。

https://www.cnblogs.com/qi-dian-ao/p/8463639.html
https://www.cnblogs.com/jpfss/p/9928747.html

https://blog.csdn.net/qq_25337221/article/details/81669630

<? extends SomeClass>与<T extends SomeClass>
1、extends的作用
这里的限定使用关键字extends，后面可以是类也可以是接口。但这里的extends已经不是继承的含义了，应该理解为T类型是实现XX接口的类型，或者T是继承了XX类的类型

2、T表示限定类型，?表示通配类型
泛型三种：
ArrayList<T> al=new ArrayList<T>();指定集合元素只能是T类型
ArrayList<?> al=new ArrayList<?>();集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法
ArrayList<? extends E> al=new ArrayList<? extends E>();
泛型的限定：
? extends E:接收E类型或者E的子类型。
? super E:接收E类型或者E的父类型。

3、通配符，它只能在“<>”中使用
1）方法参数带有通配符会更加通用；
2）带有通配符类型的对象，被限制了与泛型相关方法的使用，只能在<>中使用，不能用与泛型相关的方法；
3）下边界通配符：可以使用返回值为泛型变量的方法；
4）上边界通配符：可以使用参数为泛型变量的方法。

    - <? extends T> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类;

    <? super T> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object;

List<? extends Father> 表示 “具有任何从Son继承类型的列表”，编译器无法确定List所持有的类型，所以无法安全的向其中添加对象。可以添加null,因为null 可以表示任何类型。所以List 的add 方法不能添加任何有意义的元素，但是可以接受现有的子类型List 赋值。--现有的子类型不明白啥意思？？？？

通配符<?>和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。
public <T> List<T> fill(T... t);

但通配符<?>没有这种约束，List<?>单纯的就表示：集合里放了一个东西，是什么我不知道。

所以这里的错误就在这里，List<? extends Father>里什么都放不进去。

List<? extends Father> list不能进行add，但是，这种形式还是很有用的，虽然不能使用add方法，但是可以在初始化的时候一个Season指定不同的类型。比如：

List<? extends Father> list1 = getFatherList();//getFatherList方法会返回一个Father的子类的list


//super只能添加（指add方法不报错）Father和Father的子类，不能添加Father的父类,读取出来的东西只能存放在Object类里

PECS（Producer Extends Consumer Super）原则，已经很好理解了：

    频繁往外读取内容的，适合用上界Extends。
    经常往里插入的，适合用下界Super。

总结

    extends 可用于返回类型限定，不能用于参数类型限定（换句话说：? extends xxx 只能用于方法返回类型限定，jdk能够确定此类的最小继承边界为xxx，只要是这个类的父类都能接收，但是传入参数无法确定具体类型，只能接受null的传入）。
    super 可用于参数类型限定，不能用于返回类型限定（换句话说：? supper xxx 只能用于方法传参，因为jdk能够确定传入为xxx的子类，返回只能用Object类接收）。
    ? 既不能用于方法参数传入，也不能用于方法返回。

    带有super超类型限定的通配符可以向泛型对象中写入，带有extends子类型限定的通配符可以向泛型对象读取。


