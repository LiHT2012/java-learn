1. 内部类分为 成员内部类，局部内部类，匿名内部类和 静态内部类。

. 成员内部类：a。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）
          b。当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。
      如果要访问外部类的同名成员，需要通过： 外部类.this.成员变量/方法。
        c。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。
        成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：
        Outter outter = new Outter();
        Outter.Inner inner = outter.new Inner();  //必须通过Outter对象来创建
        d。内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限（即default）

. 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

. 一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。
    匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。
    匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。
    匿名内部类定义和实例化形式如下：
    new 父类构造方法（参数）{ 
             //注：该方法名必须在父类中已经存在
         修饰符 返回参数类型 方法名（参数列表）{
               。。。
         }
    }

. 静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法.
  在没有外部类的对象的情况下，可以创建静态内部类的对象
  Outter.Inner inner = new Outter.Inner();

2. 深入理解

. 为什么成员内部类可以无条件访问外部类？
  编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件.编译之后，出现了两个字节码文件：Outer.Class, Outer$Inner.Class.
  编译器会默认为成员内部类添加了一个指向外部类对象的引用.
  虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用

. 为什么局部内部类和匿名内部类只能访问局部final变量？
  默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）
  如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。
  为防止数据不一致，因此需要final进行限定，允许修改变量值或不允许引用指向新对象。

. 静态内部类是不持有指向外部类对象的引用的.

3. 为什么在Java中需要内部类？总结一下主要有以下四点：
　　1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，
  内部类最大的优点就在于它能够非常好的解决多重继承的问题
　　2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。
　　3.方便编写事件驱动程序
　　4.方便编写线程代码

4. 例题
.  class Outter
  {
    private int a = 1;
    class Inner {
        private int a = 2;
        public void print() {
            int a = 3;
            System.out.println("局部变量：" + a);//3
            System.out.println("内部类变量：" + this.a);//2
            System.out.println("外部类变量：" + Outter.this.a);//1
        }
    }
  }

. 创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()
  创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()

. 关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：
  1）成员内部类的引用方式必须为 Outter.Inner.
  2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()
  class WithInner {
    class Inner{

        }
  }
  class InheritInner extends WithInner.Inner {

      // InheritInner() 是不能通过编译的，一定要加上形参
      InheritInner(WithInner wi) {
          wi.super(); //必须有这句调用
      }

      public static void main(String[] args) {
          WithInner wi = new WithInner();
          InheritInner obj = new InheritInner(wi);
      }
  }































----
----
