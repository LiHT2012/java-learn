----
JVM

1、JVM的内存结构。

2、JVM方法栈的工作过程，方法栈和本地方法栈有什么区别。

3、JVM的栈中引用如何和堆中的对象产生关联。

4、可以了解一下逃逸分析技术。

5、GC的常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势。

6、标记清除和标记整理算法的理解以及优缺点。

7、eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。

8、JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型。

9、强软弱虚引用的区别以及GC对他们执行怎样的操作。

10、Java是否可以GC直接内存。

11、Java类加载的过程。

12、双亲委派模型的过程以及优势。

13、常用的JVM调优参数。

14、dump文件的分析。

15、Java有没有主动触发GC的方式（没有）。
----



线上机器的jvm进程频繁FullGC(大约每10分钟一次)，登陆机器发现jvm参数只配置了最大堆内存，其他配置都是系统默认配置，问我如何排查并优化？

我的理解是利用visualvm去查看内存使用量曲线图，如果内存使用量一直维持在较高水平，那就是堆内存不够，需要调大一点。如果频繁发生抖动，那就是程序频繁生成对象并且进行回收，
优化代码，保存可重用的对象不要频繁生成。如果内存使用量一直增长，那就是发生内存泄漏或者内存碎片，需要排查代码或者把cms收集器调成gc几次就执行一次标记整理算法来搞定内存碎片

https://yq.aliyun.com/articles/699342#
https://yq.aliyun.com/articles/699342?do=login#

JVM总体上是由类装载子系统（ClassLoader）、运行时数据区、执行引擎、内存回收这四个部分组成。其中我们最为关注的运行时数据区，
也就是JVM的内存部分则是由方法区（Method Area）、JAVA堆（Heap）、虚拟机栈（Stack）、程序计数器、本地方法栈这几部分组成；
除此以外，在概念中还有一个直接内存的概念，事实上这部分内存并不属于虚拟机规范中定义的内存区域，但是因为在JDK1.4+后新加的NIO类，
以及JDK1.8+后的Metaspace的关系，所以在讨论JVM时也经常会被放到一起讨论。

jvm内存布局

    程序计数器：当前线程正在执行的字节码的行号指示器，线程私有，唯一一个没有规定任何内存溢出错误的情况的区域。

    Java虚拟机栈：线程私有，描述Java方法执行的内存模型，每个方法运行时都会创建一个栈帧，存放局部变量表、操作数栈、动态链接、方法出口等信息，每个方法的运行到结束
    对应一个栈帧的入栈和出栈。会有StackOverFlowError异常（申请的栈深度大于虚拟机所允许深度）和OutOfMemoryError异常（线程无法申请到足够内存）。

    本地方法栈：功能与Java虚拟机栈相同，不过是为Native方法服务。

    java堆：线程共享，存放实例对象和数组对象，申请空间不足抛出OutOfMemoryError异常。

    方法区：线程共享，存储已被虚拟机加载的类的类信息、常量、静态变量、编译后的代码；运行时常量池存放class文件中描述的符号引用和直接引用，具有动态性。
    方法空间不足时抛出OutOfMemoryError异常。

    直接内存：JVM规范之外的，NIO类引入了一种基于通道和缓冲区的I/O方式，可使用Native函数库直接分配内存，通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的
    引用进行操作，避免了在Java堆和Native堆中来回复制数据。

Java堆存储的是对象，而Java栈内存是方法执行时所需要的局部变量，其中就包括堆中对象的引用。

Java虚拟机栈是线程私有，生命周期与线程相同。创建线程的时候就会创建一个java虚拟机栈。

虚拟机执行java程序的时候，每个方法都会创建一个栈帧，栈帧存放在java虚拟机栈中，通过压栈出栈的方式进行方法调用。

栈帧又分为一下几个区域：局部变量表、操作数栈、动态连接、方法出口等。
平时我们所说的变量存在栈中，这句话说的不太严谨，应该说局部变量存放在java虚拟机栈的局部变量表中。
java的8中基本类型的局部变量的值存放在虚拟机栈的局部变量表中，如果是引用型的变量，则只存储对象的引用地址。

本地方法栈(Native Stack)

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。
程序计数器（PC Register）

程序计数器就是记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。
Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。

直接内存

直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。

    使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
    使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

堆和堆栈的垃圾回收：

    堆栈不存在垃圾回收的问题， 直接压栈就可以了。?????

    堆的话，需要复杂的垃圾回收机制。
    垃圾回收是对堆来进行操作，堆中的对象是否有效， 是通过遍历堆栈来获取的， 就是一个引用计数的问题

    一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。
    垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。

==== 垃圾回收算法
标记清除法：
    容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块儿大小但是小于其中两块儿的和），会提前触发垃圾回收
    扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）

适用场合：
   存活对象较多的情况下比较高效
   适用于年老代（即旧生代）


复制算法：会浪费一部分内存。年轻代使用这种算法。
现在的商业虚拟机都采用这种收集算法来回收新生代。
适用场合：
   存活对象较少的情况下比较高效
   扫描了整个空间一次（标记存活对象并复制移动）
   适用于年轻代（即新生代）：基本上98%的对象是”朝生夕死”的，存活下来的会很少

缺点：
   需要一块儿空的内存空间
   需要复制移动对象


标记-整理算法：标记阶段与标记-清除算法相同，标记完成后将所有存活对象向一端移动，然后清除掉端边界外对象。
分代收集算法：根据对象存活周期分为将内存分为新生代与老年代，新生代采取复制算法，老年代采用标记清除或标记整理算法。

垃圾回收器：
Serial 收集器：单线程

parNew收集器：serial的多线程版本。

parallel scavenge收集器：年轻代多线程并行收集。设计目标是实现一个可控的吞吐量（cpu运行代码时间/cpu消耗的总时间）。

Serial Old收集器：Serial老年代版本。

CMS：目标是获得最短回收停顿时间，基于标记清除算法。初始标记和重新标记需要停顿所有用户线程。
缺点：无法处理浮动垃圾、有空间碎片的产生、对CPU敏感。

G1收集器：唯一一个可同时用于老年代与新生代的收集器。采用标记整理算法

垃圾回收对象时程序的逻辑是否可以继续执行？
不同回收器不同：Serial、ParNew会暂停用户所有线程工作；CMS、G1会在某一阶段暂停用户线程。

内存分配策略
    对象优先在Eden分配：若Eden无空间，Java虚拟机发起一次Minor GC。

    大对象直接进入老年代：大对象指需要大量连续内存空间的对象（如长数组、长字符串）

    长期存活的对象进入老年代：每个对象有一个对象年龄计数器，age=15晋升为老年代。age+1的两个情况：
    对象在Eden出生并经过一次Minor GC存活且被survivor容纳；在survivor区经历过一次minor GC。

空间分配担保

  在Minor GC之前，先检查老年代最大可用连续空间是否大于新生代所有空间总和，成立则此次GC安全

  不成立，查看是否允许担保失败设置为true，不允许则进行Full GC

  允许，看老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，不成立则Full GC

  成立，则进行Minor GC


Minor GC：从新生代回收内存，关键是Eden区内存不足，造成不足的原因是Java对象大部分是朝生夕死(java局部对象)，
而死掉的对象就需要在合适的时机被JVM回收

Major GC：从老年代回收内存，一般比Minor GC慢10倍以上。

Full GC：对整个堆来说的，出现Full GC通常伴随至少一次Minor GC，但非绝对。Full GC被触发的时候：老年代内存不足；
持久代内存不足；统计得到的Minor GC晋升到老年代平均大小大于老年代空间。


==== .java虚拟机new一个对象的创建过程

  在常量池中查看是否有new的参数对应的类的符号引用，并检查这个符号引用对应的类是否被加载、解析、初始化

  加载后，为新对象分配内存空间，对象多需要的内存大小在类被加载之后就被确定（堆内分配内存：指针碰撞、空闲列表）。

  将分配的空间初始化为零值。

  对对象头进行必要设置（实例是哪个类的实例、类的元信息数据、GC分代年龄等）。

  执行方法，按照程序的值初始化。

  java中方法区存放哪些东西？jvm如何控制方法区的大小以及内存溢出的原因和解决

  方法区大小不是固定的，jvm可根据需要动态调整。方法区主要存放类信息、常量、静态变量、编译后的代码。

  控制方法区大小：减少程序中class数量、尽量使用较少的静态变量
  修改：-XX:MaxPermSize调大 JVM最大允许分配的非堆内存，按需分配

https://www.cnblogs.com/mingforyou/archive/2012/03/03/2378143.html

  StackOverflowError异常：线程的方法嵌套调用层次太多，随着Java栈中桢的增多，最终会由于该线程Java栈中所有栈帧总和
  大于-Xss设置的值而产生此异常。

.jvm OutMemory的种类

  堆溢出：被缓存的实例对象，大的map，list引用大的对象等

  栈溢出：栈帧太多

  方法区溢出：加载很多类会有可能出现，GC不会在主程序运行期对此区域进行清理，可通过设置jvm启动参数解决：
  -XX:MaxPermSize=256m

可以作为GC Root的对象：

    虚拟机栈中引用的对象

    方法区中类静态属性引用的对象

    方法区中常量引用的对象

    本地方法栈中Native方法引用的对象

java -version
java version "1.8.0_191"
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)//jvm类型

目前有三大Java虚拟机：HotSpot，oracle JRockit，IBM J9。JRockit是oracle发明的，用于其WebLogic服务器，IBM JVM是IBM发明的用于其Websphere服务器
（所以在某行开发的时候，他们用的是IBM的JDK，因为他们使用的IBM的应用程序服务器Websphere，使用其他JDK可能存在兼容性问题）。JRockit和J9不存在永久代这种说法。
这里只讨论HotSpot虚拟机，这也是目前使用的最多的JVM。



方法区和永久代
https://www.jianshu.com/p/66e4e64ff278

在Java虚拟机中，方法区是可供各线程共享的运行时内存区域。
在不同的JDK版本中，方法区中存储的数据是不一样的。
在JDK1.6及之前，运行时常量池是方法区的一个部分，同时方法区里面存储了类的元数据信息、静态变量、
即时编译器编译后的代码（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）等。
在JDK1.7及以后，JVM已经将运行时常量池从方法区中移了出来，在JVM堆开辟了一块区域存放常量池。

方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。

HotSpot虚拟机在1.8之后已经取消了永久代，改为元空间，类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。
所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。这项改造也是有必要的，永久代的调优是很困难的，
虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。
永久代中的元数据的位置也会随着一次full GC发生移动，比较消耗虚拟机性能。同时，HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。
将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化。

1.对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。

2.导致Full GC的原因

1)年老代（Tenured）被写满

调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。

2)持久代Pemanet Generation空间不足

增大Perm Gen空间，避免太多静态对象 ， 控制好新生代和旧生代的比例

3)System.gc()被显示调用

垃圾回收不要手动触发，尽量依靠JVM自身的机制

3.系统崩溃前的一些现象：

   每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s
   FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC
   年老代的内存越来越大并且每次FullGC后年老代没有内存被释放

之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。

4.jvm调优的方法步骤：
{
  1）监控GC的状态

  使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化

  2）.生成堆的dump文件

  通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。

  3）.分析dump文件

  打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux，几种工具打开该文件：

     Visual VM
     IBM HeapAnalyzer
     JDK 自带的Hprof工具
     Mat(Eclipse专门的静态内存分析工具)推荐使用

  备注：文件太大，建议使用Eclipse专门的静态内存分析工具Mat打开分析。

  4）.分析结果，判断是否需要优化

  如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。

  注：如果满足下面的指标，则一般不需要进行GC：

     Minor GC执行时间不到50ms；
     Minor GC执行不频繁，约10秒一次；
     Full GC执行时间不到1s；
     Full GC执行频率不算频繁，不低于10分钟1次；

  5）.调整GC类型和内存分配

  如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。

  6）.不断的分析和调整

  通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。
}

JVM调优参数参考

1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;

2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。

比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。

3.年轻代和年老代设置多大才算合理

1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC

2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率

如何选择应该依赖应用程序对象生命周期的分布情况： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。
但很多应用都没有这样明显的特性。

在抉择时应该根 据以下两点：

（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 。

（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。
但应该给年老代至少预留1/3的增长空间。

4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。

5.线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。

理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。


https://blog.csdn.net/zhan_lang/article/details/88567569

配置回收器时，经常使用的参数：

    -XX:+UseSerialGC：在新生代和老年代使用串行收集器

    -XX:+UseParNewGC：在新生代使用并行收集器

    -XX:+UseParallelGC ：新生代使用并行回收收集器，更加关注吞吐量

    -XX:+UseParallelOldGC：老年代使用并行回收收集器

    -XX:ParallelGCThreads：设置用于垃圾回收的线程数

    -XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器

    -XX:ParallelCMSThreads：设定CMS的线程数量

    -XX:+UseG1GC：启用G1垃圾回收器
